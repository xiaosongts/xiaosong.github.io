<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on 小宋小宋?</title>
    <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/</link>
    <description>Recent content in MySQL on 小宋小宋?</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This is a customized copyright.</copyright>
    <lastBuildDate>Fri, 25 Oct 2024 12:00:00 +0800</lastBuildDate>
    <atom:link href="https://github.com/yushan-blog/xiaosong.github.io.git/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基础知识</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/basic/</link>
      <pubDate>Fri, 24 May 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/basic/</guid>
      <description>&lt;h3 id=&#34;数据类型&#34;&gt;数据类型&lt;/h3&gt;&#xA;&lt;p&gt;char和varchar&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;char：定长字符串，当实际的字符串长度小于定义的长度，则会在尾部填充空格，检索时会去掉空格&lt;/li&gt;&#xA;&lt;li&gt;varchar：不定长字符串，使用额外的字节来记录实际的字符串长度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;decimal和float、double&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;decimal：定点数，可以表示精确的小数&lt;/li&gt;&#xA;&lt;li&gt;float、double：浮点数，可以表示近似的小数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;null&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是&lt;code&gt;不确定的值&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;视为相等的情况：分组group by 、排序 order by 、去重distinct&lt;/li&gt;&#xA;&lt;li&gt;视为不相等的情况：比较 =&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;聚合函数中&#xA;&lt;ul&gt;&#xA;&lt;li&gt;sum  avg min max 忽略null值&lt;/li&gt;&#xA;&lt;li&gt;count(*)会记录null&lt;/li&gt;&#xA;&lt;li&gt;count(属性名)会忽略null&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;&#39;&#39;&lt;/code&gt;：这个是空字符串，长度为0，没有值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;码&#34;&gt;码&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;码：能够唯一标识一个实体的属性&lt;/li&gt;&#xA;&lt;li&gt;候选码：属性、属性组能够唯一标识一个实体，而其子集不能标识&lt;/li&gt;&#xA;&lt;li&gt;主码：从候选码中选出来的一个&lt;/li&gt;&#xA;&lt;li&gt;外码：一个关系的属性是另一个关系的主码&lt;/li&gt;&#xA;&lt;li&gt;主属性、非主属性：是否是候选码的属性里&lt;/li&gt;&#xA;&lt;li&gt;e-r图：实体联系图，实体、属性和联系&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;函数依赖&#34;&gt;函数依赖&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;针对的是  非主属性和主键的主属性之间的依赖关系，也就是由什么来确定什么&lt;/li&gt;&#xA;&lt;li&gt;如范式关系 R(学号，姓名，性别，班级，班主任，课程号，课程名，学时数，成绩)&lt;/li&gt;&#xA;&lt;li&gt;完全函数依赖：（学号，课程号）-&amp;gt;成绩，才能确定一门课的成绩&lt;/li&gt;&#xA;&lt;li&gt;部分函数依赖：（学号，课程号）-&amp;gt;姓名、性别、班级，这几个只依赖于主属性 学号&lt;/li&gt;&#xA;&lt;li&gt;传递函数依赖：不能直接确定关系，如  班级和学号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;范式&#34;&gt;范式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1NF(第一范式)：属性不可再分。&lt;/li&gt;&#xA;&lt;li&gt;2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的&lt;code&gt;部分函数依赖&lt;/code&gt;，非主属性都&lt;code&gt;完全依赖于主键的主属性&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的&lt;code&gt;传递函数依赖&lt;/code&gt; 。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;连接&#34;&gt;连接&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;on、where的区别：on是在生成连接临时表的时候使用，where是在临时表生成之后再进行筛选&lt;/li&gt;&#xA;&lt;li&gt;1:1&lt;/li&gt;&#xA;&lt;li&gt;1:n&lt;/li&gt;&#xA;&lt;li&gt;m:n&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>相关配置</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/config/</link>
      <pubDate>Mon, 21 Oct 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/config/</guid>
      <description>&lt;h2 id=&#34;限制登录次数&#34;&gt;限制登录次数&lt;/h2&gt;&#xA;&lt;p&gt;需求：当使用账号登录mysql时，如果登录失败超过一定次数，将会延迟响应时间&lt;/p&gt;&#xA;&lt;p&gt;参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;connection_control_failed_connections_threshold：假设值为5，即客户端连续失败登录5次后，后续的登录请求将被延迟&lt;/li&gt;&#xA;&lt;li&gt;connection_control_min_connection_delay：设置超过失败次数阈值后，客户端下次登录请求的最小延迟时间（以毫秒为单位）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;配置文件中，&#xA;[mysqld]&#xA;plugin-load-add=connection_control.so&#xA;connection_control_failed_connections_threshold=5&#xA;connection_control_min_connection_delay=2000&#xA;connection_control_max_connection_delay=10000&lt;/p&gt;&#xA;&lt;p&gt;测试流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;配置好限制次数和延迟时间，假设：5次、10秒&lt;/li&gt;&#xA;&lt;li&gt;准备好一个用户：test/p123&lt;/li&gt;&#xA;&lt;li&gt;sql：SELECT * FROM information_schema.connection_control_failed_login_attempts;&lt;/li&gt;&#xA;&lt;li&gt;先测试登录失败5次&lt;/li&gt;&#xA;&lt;li&gt;执行sql，应该是5次&lt;/li&gt;&#xA;&lt;li&gt;再测试登录失败1次&lt;/li&gt;&#xA;&lt;li&gt;执行sql，应该是6次，并且效果会有10秒延迟&lt;/li&gt;&#xA;&lt;li&gt;再正确登录&lt;/li&gt;&#xA;&lt;li&gt;会有10秒延迟&lt;/li&gt;&#xA;&lt;li&gt;执行sql，会查不到了&lt;/li&gt;&#xA;&lt;li&gt;然后再正确登录一次，不会有延迟&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;清除登录失败的次数&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;重启mysql服务&lt;/li&gt;&#xA;&lt;li&gt;重新设置限制次数：set global connection_control_failed_connections_threshold=2;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>存储引擎</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/engines/</link>
      <pubDate>Fri, 24 May 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/engines/</guid>
      <description>&lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;&#xA;&lt;p&gt;一些命令：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;show engines;&lt;/li&gt;&#xA;&lt;li&gt;select version();&lt;/li&gt;&#xA;&lt;li&gt;select variables like &amp;lsquo;%storage_engine%&amp;rsquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;存储引擎是什么&#34;&gt;存储引擎是什么？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据需要存储，但按照什么方式进行存储，这是多种多样的。这些方式就是各种各样的存储引擎，它可以定义自己的方式，进行存储数据、检索数据、管理数据。MySQL提供了一个存储引擎的抽象概念，市面上有各种各样的存储引擎，innodb、myisam。&lt;/li&gt;&#xA;&lt;li&gt;存储引擎是作用在表上的，每个表的存储引擎可以不相同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;区别&#34;&gt;区别：&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引：InnoDB和MyISAM都支持索引，都采用B+树作为索引的数据结构。但是&#xA;&lt;ul&gt;&#xA;&lt;li&gt;InnoDB 索引文件和数据文件在一起的，每个节点都存储。&lt;/li&gt;&#xA;&lt;li&gt;MyISAM 是分开的，非聚簇索引，节点指向数据文件的位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;行锁：InnoDB支持行锁，MyISAM支持表锁。粒度不一样。&lt;/li&gt;&#xA;&lt;li&gt;事务：InnoDB支持事务，提供隔离级别；MyISAM不支持事务。&lt;/li&gt;&#xA;&lt;li&gt;外键：InnoDB支持外键；MyISAM不支持。但是当更新操作时，外键会触发级联更新，性能会慢，而且可能会出错。&lt;/li&gt;&#xA;&lt;li&gt;InnoDB是以页为单位存储数据的&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>索引</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/index/</link>
      <pubDate>Fri, 24 May 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/index/</guid>
      <description>&lt;h2 id=&#34;数据结构类型&#34;&gt;数据结构类型&lt;/h2&gt;&#xA;&lt;p&gt;Hash：查找速度O(1)，但是会出现Hash冲突，解决冲突可以使用拉链法。但是查询一个范围时，需要多次hash映射，才能得到全部数据。O(N)&lt;/p&gt;&#xA;&lt;p&gt;二叉搜索树 ：理想速度O(logN)。但是非递减数据会退化成链表。&lt;/p&gt;&#xA;&lt;p&gt;平衡二叉树 ：解决二叉搜索树的问题。各种操作最坏情况复杂度O(logN)。但是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;元素多，高度还是会高&lt;/li&gt;&#xA;&lt;li&gt;维护平衡，代价高，通过各种旋转，O(logN)。&lt;/li&gt;&#xA;&lt;li&gt;每个节点存储的数据少，也就是节点上每次加载的数据太少，即便找到了数据，也需要多次磁盘IO去取数据。&lt;/li&gt;&#xA;&lt;li&gt;可以范围查询，中序遍历就是有序的数据。&lt;/li&gt;&#xA;&lt;li&gt;因为数据量比较大，一次性不一定能把数据全部加载到内存中。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;红黑树 ：解决平衡二叉树的&lt;code&gt;维护平衡&lt;/code&gt;的问题。通过&lt;code&gt;颜色的改变&lt;/code&gt;，可以在O(1)的复杂度下维护平衡。但是，缺点还是平衡二叉树大差不差。&lt;/p&gt;&#xA;&lt;h2 id=&#34;b树&#34;&gt;B树&lt;/h2&gt;&#xA;&lt;p&gt;每个节点都存储数据,每一个节点都会存储指针&#xA;概念&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;阶：一个数的最大子节点的个数，同时也控制每一个节点的键的数量的上下限&lt;/li&gt;&#xA;&lt;li&gt;根节点，中间节点：非根、非叶子结点，叶子结点&lt;/li&gt;&#xA;&lt;li&gt;键值对：是每个节点所存储的数据，每个节点有一个最小键、一个最大键，键的值是按照非递减的规则排序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;重点&#xA;B数的结构控制，假设B树的阶数为 m&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根结点至少有两个子女。&lt;/li&gt;&#xA;&lt;li&gt;中间节点：k-1个键和k个孩子(指针)，其中k的范围[m/2,m]&lt;/li&gt;&#xA;&lt;li&gt;叶子节点：k-1个元素，其中k的范围[m/2,m]&lt;/li&gt;&#xA;&lt;li&gt;叶子节点都在一层&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;通过这些规则，B树可以达到自平衡&#xA;插入：键的非递减顺序、超过范围进行父节点的选举&#xA;删除：不足范围进行合并&lt;/p&gt;&#xA;&lt;h2 id=&#34;b树-1&#34;&gt;B+树&lt;/h2&gt;&#xA;&lt;p&gt;只有叶子结点存储完整数据，并且每个叶子节点可以链接&#xA;m阶的B+树每个节点的键的范围：[m/2-1,m-1]；向上取整&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;叶子节点中存储全部的数据&lt;/li&gt;&#xA;&lt;li&gt;每个&lt;code&gt;叶子节点采用双向链表&lt;/code&gt;进行关联&lt;/li&gt;&#xA;&lt;li&gt;中间节点：一个键对应一个子节点，共k个键；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;采用b树b树在mysql的好处&#34;&gt;采用B树、B+树在mysql的好处&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;速度：多路索引，树的高度能够降低，然后一次磁盘IO可以取出更多的数据&lt;/li&gt;&#xA;&lt;li&gt;顺序查询：B+树，叶子节点采用双向链表关联，可以进行范围查询&lt;/li&gt;&#xA;&lt;li&gt;如果需要高效的查询和插入操作，那么红黑树可能是更好的选择；&lt;/li&gt;&#xA;&lt;li&gt;如果要进行大量的数据读写操作，那么B+树可能更适合。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;聚簇索引非聚簇索引&#34;&gt;聚簇索引、非聚簇索引&lt;/h2&gt;&#xA;&lt;p&gt;聚簇索引&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;叶子结点的data包含记录的全部数据记录&lt;/li&gt;&#xA;&lt;li&gt;整条树是根据主索引建立，这就是为什么数据库表中只能有一个primary key&lt;/li&gt;&#xA;&lt;li&gt;其他是辅助索引，在根据辅助索引查询时，需要先辅助索引的data确定其主索引，再走主索引树&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;非聚簇索引&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;叶子结点的data包含指向记录数据的指针&lt;/li&gt;&#xA;&lt;li&gt;回表查询：当查询结果正是需要的索引关键字，不需要回表取数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;&#xA;&lt;h3 id=&#34;辅助索引&#34;&gt;辅助索引&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;也叫二级索引，存储的是主索引的值&lt;/li&gt;&#xA;&lt;li&gt;唯一索引，普通索引，前缀索引，全文索引都是的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;sql语句&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;alter&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;index&lt;/span&gt;/fulltext&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;index&lt;/span&gt;/&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;unique&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;column&lt;/span&gt;(index_name);&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;--前缀索引&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;create&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;(&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;index&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;column_name&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;length&lt;/span&gt;))&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;create&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;index_name&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;on&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;(&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;column_name&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;length&lt;/span&gt;)&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;);&lt;span style=&#34;color:#bbb&#34;&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;覆盖索引&#34;&gt;覆盖索引&lt;/h3&gt;&#xA;&lt;p&gt;在简单查询的时候，解决回表查询。&#xA;意思就是：如果查询的数据，正是索引关键字的属性，就直接返回，不用通过主键查询一次了&lt;/p&gt;</description>
    </item>
    <item>
      <title>日志</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/log/</link>
      <pubDate>Fri, 24 May 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/log/</guid>
      <description>&lt;h2 id=&#34;redo-log&#34;&gt;redo log&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重做日志&lt;/li&gt;&#xA;&lt;li&gt;主要是记录更新操作的细节，然后记录到文件中，为了mysql崩溃时能够恢复&lt;/li&gt;&#xA;&lt;li&gt;可以保证事务的持久性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为什么需要这个redo log&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据是存放在磁盘上，用户是通过cpu来操作的，两者之间速度是非常慢的，通常是需要缓冲池（是内存中的一个页面）作中间缓冲，&lt;strong&gt;缓存表数据与索引数据&lt;/strong&gt;，避免多次磁盘IO。&lt;/li&gt;&#xA;&lt;li&gt;但是一个更新操作完成后，代表这有数据变了，磁盘上的数据要更改。先更新了缓冲池，但是mysql进程挂了，后续无法操作，导致磁盘中没有更新，造成数据丢失。&lt;/li&gt;&#xA;&lt;li&gt;有一个暴力解决：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以在事务提交之前，将数据刷新到磁盘中&lt;/li&gt;&#xA;&lt;li&gt;但会出现多次随机IO，导致速度会非常慢&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;所以&lt;code&gt;redo log file&lt;/code&gt;就出现了，它可以记录每次更新操作，只要将更新详细细节追加到这个文件中，就代表着事务提交成功。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其中细节：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;redo log file&lt;/code&gt;出现了，但是这个文件还是在磁盘上的，如果每次事务都进行刷盘，还是会有多次磁盘IO&lt;/li&gt;&#xA;&lt;li&gt;所以还可以在内存中申请一个缓冲池&lt;code&gt;redo log buffer&lt;/code&gt;，记录redo log信息&lt;/li&gt;&#xA;&lt;li&gt;所以会有一个概念“何时将缓冲池&lt;code&gt;redo log buffer&lt;/code&gt;的数据写入到磁盘&lt;code&gt;redo log file&lt;/code&gt;文件中？”&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;刷盘策略&#34;&gt;刷盘策略&lt;/h3&gt;&#xA;&lt;p&gt;重要的概念，刷盘不是直接写入到磁盘的&lt;code&gt;redo log file&lt;/code&gt;，而是写入到文件系统的Page Cache。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参数：innodb_flush_log_at_trx_commit控制&lt;/li&gt;&#xA;&lt;li&gt;缓冲池大小快满的时候&lt;/li&gt;&#xA;&lt;li&gt;后台线程控制&lt;/li&gt;&#xA;&lt;li&gt;mysql实例关闭时&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;innodb_flush_log_at_trx_commit&#34;&gt;innodb_flush_log_at_trx_commit&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;0：每次事务提交不操作，而是由后台线程来控制，每隔1秒进行刷盘，最多丢失1秒的数据&lt;/li&gt;&#xA;&lt;li&gt;1：默认的，也是保证持久化必须的，每次事务提交就刷盘，通过&lt;code&gt;fsync&lt;/code&gt;从页缓存写入到磁盘中&lt;/li&gt;&#xA;&lt;li&gt;2：文件系统的页缓存，事务提交，刷新到页缓存，再由页缓存刷新到磁盘&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;后台线程&#34;&gt;后台线程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;innodb有一个后台线程&lt;code&gt;Page Cleaner Thread&lt;/code&gt;，会每隔一秒将&lt;code&gt;redo log buffer&lt;/code&gt;的数据写入到&lt;code&gt;page cache&lt;/code&gt;，然后调用&lt;code&gt;fsync&lt;/code&gt;从页缓存中写入到磁盘，但是刷新的是&lt;code&gt;脏页&lt;/code&gt;，未修改的数据页是不会刷新的&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;日志文件组&#34;&gt;日志文件组&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;mysql里不止一个redo文件，在mysql8中默认32个文件，采用环形数组存储。&lt;/li&gt;&#xA;&lt;li&gt;write pos：代表当前写入的位置，后移操作。&lt;/li&gt;&#xA;&lt;li&gt;check point：检查点，代表擦除的位置，后移操作。&lt;/li&gt;&#xA;&lt;li&gt;write pos之后和check point之前，这两个之间代表是可以写入数据的部分。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;bin-log&#34;&gt;bin log&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redo log是保证事务的持久性，是属于InnoDB的&lt;/li&gt;&#xA;&lt;li&gt;bin log二进制日志，是记录更新语句的原始逻辑，类似于Redis的AOF机制，可以保证&lt;code&gt;一致性&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主从复制&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主节点将操作写入到&lt;code&gt;bin log&lt;/code&gt;文件中&lt;/li&gt;&#xA;&lt;li&gt;从节点从&lt;code&gt;bin log&lt;/code&gt;文件中获取详细信息，实现数据同步&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;审计、监控&lt;/li&gt;&#xA;&lt;li&gt;数据恢复&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以恢复指定时间点的数据&lt;/li&gt;&#xA;&lt;li&gt;重新执行sql语句&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;记录格式&#34;&gt;记录格式&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;statement&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录语句的原始状态，可以理解成一模一样&lt;/li&gt;&#xA;&lt;li&gt;会出现数据不一致的问题，如插入语句中有now()，date()函数之类的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;row&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录语句的更新的具体数据&lt;/li&gt;&#xA;&lt;li&gt;但是会导致文件比较大&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;mixed&#xA;&lt;ul&gt;&#xA;&lt;li&gt;会先判断语句是否会导致不一致的问题&lt;/li&gt;&#xA;&lt;li&gt;再去决定用什么存储&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;具体细节&#34;&gt;具体细节&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;和redo log一样，还是在内存有一个缓存，&lt;code&gt;binlog cache&lt;/code&gt;，在磁盘中还有一个&lt;code&gt;binlog file&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;binlog的是以事务为单位的，只有在事务提交后，才会记录，写入文件。&lt;/li&gt;&#xA;&lt;li&gt;刷新&lt;code&gt;binlog cache&lt;/code&gt;时机，由变量&lt;code&gt;sync_binlog&lt;/code&gt;决定&#xA;&lt;ol&gt;&#xA;&lt;li&gt;0，事务提交后，不刷新，由系统决定&lt;/li&gt;&#xA;&lt;li&gt;N，累积N个事务后，刷新缓冲区，执行&lt;code&gt;fsync&lt;/code&gt;命令，刷入磁盘&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;undo-log&#34;&gt;undo log&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;重做日志&lt;/li&gt;&#xA;&lt;li&gt;实现回滚，当一个事务异常后，可以根据这个文件进行回滚操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;脏页&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内存区和磁盘区的数据不一致，此时内存区的数据页称为”脏页“&lt;/li&gt;&#xA;&lt;li&gt;即便不一致，但是有redo log，也无妨&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;“脏页”变成“干净页”&lt;/p&gt;</description>
    </item>
    <item>
      <title>事务</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/transaction/</link>
      <pubDate>Fri, 24 May 2024 15:14:01 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/transaction/</guid>
      <description>&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;是指一组逻辑操作，看成一个实体，这些操作要么全部正确执行，若出错一个在全部不执行，不造成修改操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;事务使用&#34;&gt;事务使用&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;设置隔离级别：set session transaction isolation level read uncommited;&lt;/li&gt;&#xA;&lt;li&gt;开启事务：start transcation&lt;/li&gt;&#xA;&lt;li&gt;设置保存点：savepoint&lt;/li&gt;&#xA;&lt;li&gt;提交事务：commit&lt;/li&gt;&#xA;&lt;li&gt;回滚事务：rollback&lt;/li&gt;&#xA;&lt;li&gt;回滚到保存点：rollback to&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;acid&#34;&gt;ACID&lt;/h2&gt;&#xA;&lt;p&gt;利用 AID来保证最终的C&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;原子性 atomic：事务的所有操作要么全部执行成功，要么全部执行失败。&lt;/li&gt;&#xA;&lt;li&gt;一致性 consistency：事务执行之后，数据应该保持一致，如修改前后资源的平衡。&lt;/li&gt;&#xA;&lt;li&gt;隔离性 isolation：事务与事务之间应该相互隔离，互不影响。&lt;/li&gt;&#xA;&lt;li&gt;持久性 durable：事务执行后的操作结果应该是持久的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;&#xA;&lt;p&gt;假设两个事务：T1，T2&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;脏读：T1查询到了T2修改的数据，但是T2没有提交，这时T2可以随时回滚，抛弃它自己修改的数据；然后T1若是对自己查询的数据进行操作，就会出现最终数据错误。&lt;/li&gt;&#xA;&lt;li&gt;不可重复读：T1在一直读取数据的时候，这时T2对这一个数据进行了修改，导致T1读取的数据变了。&lt;/li&gt;&#xA;&lt;li&gt;幻读：T1在查询一个区间时，突然T2向这一个区间插入了一个新数据，导致T1再次查询时，出现了不认识的新数据，就像出现了幻觉一样。&lt;/li&gt;&#xA;&lt;li&gt;修改丢失：T1和T2读取同一个数据然后进行修改，会出现T1的修改被T2的修改替换了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;隔离级别&#34;&gt;隔离级别&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;代表的是多个事务之间占用相同的资源是如何隔离的&lt;/li&gt;&#xA;&lt;li&gt;解决事务之间的问题&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;read-uncommitted&#34;&gt;READ-UNCOMMITTED&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读未提交&lt;/li&gt;&#xA;&lt;li&gt;允许一个事务读取另一个事务未提交的修改数据&lt;/li&gt;&#xA;&lt;li&gt;都不能解决&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;read-committed&#34;&gt;READ-COMMITTED&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读已提交&lt;/li&gt;&#xA;&lt;li&gt;允许一个事务读取另一事务已提交的数据&lt;/li&gt;&#xA;&lt;li&gt;脏读能解决，因为此隔离可以防止读取未提交的数据&lt;/li&gt;&#xA;&lt;li&gt;不可重复读、幻读不能解决&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;repeatable-read&#34;&gt;REPEATABLE-READ&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可重复读&lt;/li&gt;&#xA;&lt;li&gt;对同一字段多次读取结果都是一致的&lt;/li&gt;&#xA;&lt;li&gt;脏读能解决&lt;/li&gt;&#xA;&lt;li&gt;不可重复读能解决，共享锁&lt;/li&gt;&#xA;&lt;li&gt;幻读不能解决，也可以解决，如记录锁和间隙锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;serializable&#34;&gt;SERIALIZABLE&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;串行&lt;/li&gt;&#xA;&lt;li&gt;事务一个一个执行，不存在并行，也就不存在并行事务带来的问题&lt;/li&gt;&#xA;&lt;li&gt;都能解决；通过加&lt;code&gt;锁&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;锁&#34;&gt;锁&lt;/h2&gt;&#xA;&lt;p&gt;按照模式上分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;乐观锁&lt;/li&gt;&#xA;&lt;li&gt;悲观锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;按照粒度上分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;全局锁&lt;/li&gt;&#xA;&lt;li&gt;表级锁&lt;/li&gt;&#xA;&lt;li&gt;页级锁&lt;/li&gt;&#xA;&lt;li&gt;行级锁：在存储引擎之上的，利用索引机制来进行加锁&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;按照属性上分类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;共享锁 S锁：读锁，在多个事务中可以多次获取这个锁进行操作，同一时刻可以多个线程拥有&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;排它锁 X锁：写锁，独占的，其他事务对其不能再加锁，同一时刻只能有一个线程拥有&lt;/p&gt;</description>
    </item>
    <item>
      <title>主从复制</title>
      <link>https://github.com/yushan-blog/xiaosong.github.io.git/database/master_slave/</link>
      <pubDate>Fri, 25 Oct 2024 12:00:00 +0800</pubDate>
      <guid>https://github.com/yushan-blog/xiaosong.github.io.git/database/master_slave/</guid>
      <description>&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;p&gt;主从复制是 MySQL 数据库管理系统（MySQL Database Management System，MySQL DBMS）中一个非常常用的功能，它允许一个数据库服务器作为主服务器，另一个数据库服务器作为从服务器，主服务器的数据会被复制到从服务器，从而实现数据的备份和容灾。&lt;/p&gt;&#xA;&lt;p&gt;主从交接的数据：二进制日志文件（Binary Log），主服务器的所有修改操作都会记录在这个日志文件中，通过将日志文件传送给从服务器，从服务器用来执行这个日志文件，就可以实现数据的同步功能。&lt;/p&gt;&#xA;&lt;p&gt;这点和Redis的主从相似，其中都会涉及到日志文件的当前位置，记录主从数据的差异点，进行数据同步，因为不可能每次都进行全量同步。&lt;/p&gt;&#xA;&lt;h2 id=&#34;先上手使用&#34;&gt;先上手使用&lt;/h2&gt;</description>
    </item>
  </channel>
</rss>
